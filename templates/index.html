<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Protocol Verification - FSM Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --secondary: #ec4899;
            --accent: #10b981;
            --dark: #0f172a;
            --darker: #020617;
            --light: #f1f5f9;
            --glass: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --shadow: rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--darker);
            color: white;
            overflow-x: hidden;
            position: relative;
            min-height: 100vh;
        }

        /* Animated Gradient Background */
        .background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(135deg,
                #667eea 0%,
                #764ba2 25%,
                #f093fb 50%,
                #4facfe 75%,
                #667eea 100%);
            background-size: 400% 400%;
            animation: gradientFlow 15s ease infinite;
        }

        @keyframes gradientFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Particle Effect */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            animation: float linear infinite;
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) translateX(0) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) translateX(100px) scale(1);
                opacity: 0;
            }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 40px 20px;
            position: relative;
            z-index: 1;
        }

        /* Glassmorphism Header */
        header {
            text-align: center;
            margin-bottom: 60px;
            animation: fadeInDown 1s ease-out;
        }

        header h1 {
            font-size: clamp(2rem, 5vw, 4rem);
            font-weight: 800;
            background: linear-gradient(135deg, #fff 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            letter-spacing: -2px;
            text-shadow: 0 0 60px rgba(167, 139, 250, 0.5);
            animation: glow 3s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(167, 139, 250, 0.5)); }
            50% { filter: drop-shadow(0 0 40px rgba(167, 139, 250, 0.8)); }
        }

        header p {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 300;
            letter-spacing: 1px;
        }

        .subtitle {
            display: inline-block;
            padding: 8px 20px;
            background: var(--glass);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            border: 1px solid var(--glass-border);
            margin-top: 15px;
            font-size: 0.9rem;
            animation: float-subtle 3s ease-in-out infinite;
        }

        @keyframes float-subtle {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        /* Glass Card */
        .glass-card {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            border: 1px solid var(--glass-border);
            padding: 35px;
            box-shadow: 0 20px 60px var(--shadow);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            animation: fadeInUp 0.8s ease-out;
            position: relative;
            overflow: hidden;
        }

        .glass-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }

        .glass-card:hover::before {
            left: 100%;
        }

        .glass-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1.2fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            animation: rotate-subtle 6s linear infinite;
        }

        @keyframes rotate-subtle {
            0%, 100% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(5deg) scale(1.05); }
        }

        .card-header h2 {
            font-size: 1.6rem;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        /* SVG Canvas Improvements */
        #fsm-canvas {
            width: 100%;
            height: 650px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Modern Form Controls */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .input-wrapper {
            position: relative;
        }

        input[type="text"] {
            width: 100%;
            padding: 18px 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            font-size: 16px;
            font-family: 'JetBrains Mono', monospace;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
        }

        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        /* Premium Buttons */
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        button {
            padding: 16px 30px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.3);
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(99, 102, 241, 0.4);
        }

        button:active {
            transform: translateY(-1px);
        }

        button.secondary {
            background: linear-gradient(135deg, #ec4899, #f59e0b);
            box-shadow: 0 10px 30px rgba(236, 72, 153, 0.3);
        }

        button.success {
            background: linear-gradient(135deg, #10b981, #06b6d4);
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.3);
            grid-column: span 2;
        }

        /* Example Cards */
        .examples-grid {
            display: grid;
            gap: 12px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .examples-grid::-webkit-scrollbar {
            width: 6px;
        }

        .examples-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .examples-grid::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 10px;
        }

        .example-card {
            padding: 16px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .example-card::after {
            content: '‚Üí';
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%) translateX(0);
            opacity: 0;
            transition: all 0.3s ease;
            font-size: 20px;
        }

        .example-card:hover {
            background: rgba(99, 102, 241, 0.2);
            border-color: var(--primary);
            transform: translateX(5px);
        }

        .example-card:hover::after {
            opacity: 1;
            transform: translateY(-50%) translateX(5px);
        }

        .example-card strong {
            display: block;
            margin-bottom: 6px;
            font-size: 14px;
            color: #a78bfa;
        }

        .example-card small {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            display: block;
            margin-bottom: 8px;
        }

        .example-sequence {
            font-family: 'JetBrains Mono', monospace;
            color: #fff;
            font-size: 13px;
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
        }

        /* Results Display */
        #verification-results {
            margin-top: 25px;
            min-height: 150px;
            max-height: 500px;
            padding: 25px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
        }

        #verification-results::-webkit-scrollbar {
            width: 8px;
        }

        #verification-results::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        #verification-results::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 10px;
        }

        #verification-results::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, var(--secondary), var(--primary));
        }

        .result-summary {
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            animation: slideInLeft 0.5s ease-out;
            border-left: 4px solid;
        }

        .result-summary.valid {
            background: rgba(16, 185, 129, 0.15);
            border-left-color: var(--accent);
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.2);
        }

        .result-summary.invalid {
            background: rgba(239, 68, 68, 0.15);
            border-left-color: #ef4444;
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.2);
        }

        .result-summary h3 {
            font-size: 1.3rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .step-card {
            padding: 16px 20px;
            margin: 12px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border-left: 3px solid var(--primary);
            animation: slideInRight 0.5s ease-out;
            transition: all 0.3s ease;
        }

        .step-card:hover {
            background: rgba(99, 102, 241, 0.1);
            transform: translateX(5px);
        }

        .step-number {
            display: inline-block;
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 50%;
            text-align: center;
            line-height: 32px;
            font-weight: 700;
            margin-right: 12px;
            font-size: 14px;
        }

        .state-badge {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            margin: 0 5px;
        }

        .state-badge.from {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .state-badge.to {
            background: rgba(6, 182, 212, 0.2);
            color: #06b6d4;
            border: 1px solid rgba(6, 182, 212, 0.3);
        }

        .packet-badge {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
        }

        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 25px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        .legend-dot {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        /* Info Box */
        .info-box {
            background: rgba(99, 102, 241, 0.1);
            border-left: 4px solid var(--primary);
            padding: 18px;
            border-radius: 10px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .info-box strong {
            color: #a78bfa;
            display: block;
            margin-bottom: 8px;
        }

        /* Packet Flow Canvas */
        #packet-flow-canvas {
            width: 100%;
            height: 350px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Animations */
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse-glow {
            0%, 100% {
                transform: scale(1);
                filter: drop-shadow(0 0 10px currentColor);
            }
            50% {
                transform: scale(1.15);
                filter: drop-shadow(0 0 25px currentColor);
            }
        }

        .pulse {
            animation: pulse-glow 1.5s ease-in-out infinite;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .button-group {
                grid-template-columns: 1fr;
            }

            header h1 {
                font-size: 2.5rem;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Section Title */
        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 25px 0 15px;
            color: #a78bfa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <!-- Animated Background -->
    <div class="background"></div>

    <!-- Floating Particles -->
    <div class="particles" id="particles"></div>

    <div class="container">
        <!-- Header -->
        <header>
            <h1>üîê Network Protocol Verification</h1>
            <p>Finite State Machine Visualization System</p>
            <div class="subtitle">
                Theory of Computation ‚Ä¢ Formal Languages ‚Ä¢ Automata
            </div>
        </header>

        <!-- Main Content Grid -->
        <div class="main-grid">
            <!-- FSM Diagram Panel -->
            <div class="glass-card">
                <div class="card-header">
                    <div class="card-icon">üìä</div>
                    <h2>State Transition Diagram</h2>
                </div>

                <svg id="fsm-canvas"></svg>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #10b981;"></div>
                        <span>Initial State</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #06b6d4;"></div>
                        <span>Accepting State</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #ef4444;"></div>
                        <span>Error State</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #fbbf24; border: 3px solid #f59e0b;"></div>
                        <span>Current State</span>
                    </div>
                </div>

                <div class="info-box">
                    <strong>TCP 3-Way Handshake Protocol</strong>
                    Models TCP connection establishment using a Deterministic Finite Automaton (DFA).
                    Valid sequences transition to the ESTABLISHED state.
                </div>
            </div>

            <!-- Control Panel -->
            <div class="glass-card">
                <div class="card-header">
                    <div class="card-icon">üéÆ</div>
                    <h2>Verification Controls</h2>
                </div>

                <div class="controls">
                    <div class="input-wrapper">
                        <input
                            type="text"
                            id="packet-input"
                            placeholder="LISTEN,SYN,ACK"
                            spellcheck="false"
                        >
                    </div>

                    <div class="button-group">
                        <button onclick="resetFSM()" class="secondary">
                            üîÑ Reset
                        </button>
                        <button onclick="stepByStep()">
                            ‚è≠Ô∏è Step Mode
                        </button>
                    </div>

                    <button onclick="verifySequence()" class="success">
                        üöÄ Verify Sequence
                    </button>
                </div>

                <div class="info-box">
                    <strong>Valid Inputs:</strong>
                    LISTEN ‚Ä¢ SYN ‚Ä¢ SYN-ACK ‚Ä¢ ACK
                </div>

                <div class="section-title">üìö Example Sequences</div>
                <div class="examples-grid" id="examples-container">
                    <!-- Loaded via JavaScript -->
                </div>

                <div id="verification-results">
                    <p style="text-align: center; color: rgba(255,255,255,0.5);">
                        üëÜ Enter a packet sequence to verify
                    </p>
                </div>
            </div>
        </div>

        <!-- Packet Flow Panel -->
        <div class="glass-card">
            <div class="card-header">
                <div class="card-icon">üì°</div>
                <h2>Packet Flow Animation</h2>
            </div>
            <svg id="packet-flow-canvas"></svg>
        </div>
    </div>

    <script>
        // Create floating particles
        function createParticles() {
            const particles = document.getElementById('particles');
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
                particle.style.animationDelay = Math.random() * 5 + 's';
                particles.appendChild(particle);
            }
        }
        createParticles();

        // Global state
        let currentState = 'CLOSED';
        let fsmData = null;
        let currentSequence = [];
        let currentStep = 0;

        // Improved state positions for better visualization
        const statePositions = {
            'CLOSED': { x: 140, y: 325 },
            'LISTEN': { x: 380, y: 180 },
            'SYN_SENT': { x: 380, y: 470 },
            'SYN_RECEIVED': { x: 640, y: 325 },
            'ESTABLISHED': { x: 900, y: 325 },
            'ERROR': { x: 640, y: 550 }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadFSMDiagram();
            loadExamples();
            drawPacketFlowSetup();
        });

        // Load FSM diagram
        async function loadFSMDiagram() {
            try {
                const response = await fetch('/api/diagram');
                fsmData = await response.json();
                drawFSM();
            } catch (error) {
                console.error('Error loading FSM:', error);
            }
        }

        // Draw FSM with improved styling
        function drawFSM() {
            const svg = document.getElementById('fsm-canvas');
            svg.innerHTML = '';
            const width = svg.clientWidth;
            const height = 650;
            svg.setAttribute('viewBox', `0 0 1050 ${height}`);

            // Add definitions for gradients and filters
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Glow filter
            const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
            filter.setAttribute('id', 'glow');
            const feGaussianBlur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
            feGaussianBlur.setAttribute('stdDeviation', '4');
            feGaussianBlur.setAttribute('result', 'coloredBlur');
            filter.appendChild(feGaussianBlur);

            const feMerge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
            const feMergeNode1 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
            feMergeNode1.setAttribute('in', 'coloredBlur');
            const feMergeNode2 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
            feMergeNode2.setAttribute('in', 'SourceGraphic');
            feMerge.appendChild(feMergeNode1);
            feMerge.appendChild(feMergeNode2);
            filter.appendChild(feMerge);
            defs.appendChild(filter);

            // Arrow marker
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '12');
            marker.setAttribute('markerHeight', '12');
            marker.setAttribute('refX', '11');
            marker.setAttribute('refY', '6');
            marker.setAttribute('orient', 'auto');
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 12 6, 0 12');
            polygon.setAttribute('fill', 'rgba(255,255,255,0.6)');
            marker.appendChild(polygon);
            defs.appendChild(marker);

            svg.appendChild(defs);

            // Draw transitions
            if (fsmData && fsmData.transitions) {
                fsmData.transitions.forEach(trans => drawTransition(svg, trans));
            }

            // Draw states
            if (fsmData && fsmData.states) {
                fsmData.states.forEach(state => drawState(svg, state));
            }
        }

        // Draw state with ADVANCED animations
        function drawState(svg, stateName) {
            const pos = statePositions[stateName] || { x: 100, y: 100 };
            const isInitial = stateName === 'CLOSED';
            const isAccepting = stateName === 'ESTABLISHED';
            const isError = stateName === 'ERROR';
            const isCurrent = stateName === currentState;

            // State group
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', `state-${stateName}`);

            // Advanced glow effects for current state
            if (isCurrent) {
                // Create 3 expanding ripple rings
                for (let i = 0; i < 3; i++) {
                    const ripple = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    ripple.setAttribute('cx', pos.x);
                    ripple.setAttribute('cy', pos.y);
                    ripple.setAttribute('r', 50 + i * 15);
                    ripple.setAttribute('fill', 'none');
                    ripple.setAttribute('stroke', '#fbbf24');
                    ripple.setAttribute('stroke-width', '2');
                    ripple.setAttribute('opacity', '0');
                    g.appendChild(ripple);

                    // Animate ripple
                    animateRipple(ripple, i * 500);
                }

                // Rotating ring
                const rotatingRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                rotatingRing.setAttribute('cx', pos.x);
                rotatingRing.setAttribute('cy', pos.y);
                rotatingRing.setAttribute('r', 60);
                rotatingRing.setAttribute('fill', 'none');
                rotatingRing.setAttribute('stroke', '#f59e0b');
                rotatingRing.setAttribute('stroke-width', '3');
                rotatingRing.setAttribute('stroke-dasharray', '20 10');
                rotatingRing.setAttribute('opacity', '0.6');
                g.appendChild(rotatingRing);

                // Rotate animation
                animateRotation(rotatingRing);

                // Particle burst around current state
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    particle.setAttribute('cx', pos.x);
                    particle.setAttribute('cy', pos.y);
                    particle.setAttribute('r', 3);
                    particle.setAttribute('fill', '#fbbf24');
                    particle.setAttribute('opacity', '0.8');
                    g.appendChild(particle);

                    animateParticle(particle, pos.x, pos.y, angle, i * 100);
                }
            }

            // Outer glow ring (all states)
            const outerGlow = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerGlow.setAttribute('cx', pos.x);
            outerGlow.setAttribute('cy', pos.y);
            outerGlow.setAttribute('r', 50);
            outerGlow.setAttribute('fill', 'none');

            let glowColor = 'rgba(100, 116, 139, 0.5)';
            if (isCurrent) glowColor = 'rgba(251, 191, 36, 0.3)';
            else if (isAccepting) glowColor = 'rgba(6, 182, 212, 0.3)';
            else if (isError) glowColor = 'rgba(239, 68, 68, 0.3)';
            else if (isInitial) glowColor = 'rgba(16, 185, 129, 0.3)';

            outerGlow.setAttribute('stroke', glowColor);
            outerGlow.setAttribute('stroke-width', '8');
            outerGlow.setAttribute('filter', 'url(#glow)');
            g.appendChild(outerGlow);

            // Create radial gradient for main circle
            const defs = svg.querySelector('defs');
            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
            gradient.setAttribute('id', `state-gradient-${stateName}`);

            let color1, color2;
            if (isCurrent) {
                color1 = '#fbbf24';
                color2 = '#f59e0b';
            } else if (isAccepting) {
                color1 = '#06b6d4';
                color2 = '#0891b2';
            } else if (isError) {
                color1 = '#ef4444';
                color2 = '#dc2626';
            } else if (isInitial) {
                color1 = '#10b981';
                color2 = '#059669';
            } else {
                color1 = 'rgba(100, 116, 139, 0.7)';
                color2 = 'rgba(71, 85, 105, 0.5)';
            }

            gradient.innerHTML = `
                <stop offset="0%" style="stop-color:${color1};stop-opacity:1" />
                <stop offset="100%" style="stop-color:${color2};stop-opacity:1" />
            `;
            defs.appendChild(gradient);

            // Main circle with gradient
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', pos.x);
            circle.setAttribute('cy', pos.y);
            circle.setAttribute('r', 45);
            circle.setAttribute('fill', `url(#state-gradient-${stateName})`);
            circle.setAttribute('stroke', 'rgba(255,255,255,0.5)');
            circle.setAttribute('stroke-width', isCurrent ? '4' : '2');
            circle.setAttribute('filter', 'url(#glow)');
            g.appendChild(circle);

            // Inner highlight circle
            const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            highlight.setAttribute('cx', pos.x - 10);
            highlight.setAttribute('cy', pos.y - 10);
            highlight.setAttribute('r', 15);
            highlight.setAttribute('fill', 'rgba(255,255,255,0.3)');
            highlight.setAttribute('filter', 'url(#glow)');
            g.appendChild(highlight);

            // Double circle for accepting state with animation
            if (isAccepting) {
                const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                innerCircle.setAttribute('cx', pos.x);
                innerCircle.setAttribute('cy', pos.y);
                innerCircle.setAttribute('r', 38);
                innerCircle.setAttribute('fill', 'none');
                innerCircle.setAttribute('stroke', 'rgba(255,255,255,0.8)');
                innerCircle.setAttribute('stroke-width', '2');
                innerCircle.setAttribute('stroke-dasharray', '5 5');
                g.appendChild(innerCircle);

                // Animate dashes
                animateDashes(innerCircle);
            }

            // State label with shadow
            const textShadow = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textShadow.setAttribute('x', pos.x + 1);
            textShadow.setAttribute('y', pos.y + 6);
            textShadow.setAttribute('text-anchor', 'middle');
            textShadow.setAttribute('font-size', '13');
            textShadow.setAttribute('font-weight', 'bold');
            textShadow.setAttribute('fill', 'rgba(0,0,0,0.5)');
            textShadow.setAttribute('font-family', 'JetBrains Mono, monospace');
            textShadow.textContent = stateName.replace('_', ' ');
            g.appendChild(textShadow);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', pos.x);
            text.setAttribute('y', pos.y + 5);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '13');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', 'white');
            text.setAttribute('font-family', 'JetBrains Mono, monospace');
            text.textContent = stateName.replace('_', ' ');
            g.appendChild(text);

            // Initial state arrow with animation
            if (isInitial) {
                const arrowLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                arrowLine.setAttribute('d', `M ${pos.x - 90} ${pos.y} L ${pos.x - 50} ${pos.y}`);
                arrowLine.setAttribute('stroke', 'rgba(255,255,255,0.6)');
                arrowLine.setAttribute('stroke-width', '3');
                arrowLine.setAttribute('marker-end', 'url(#arrowhead)');
                arrowLine.setAttribute('stroke-dasharray', '100');
                arrowLine.setAttribute('stroke-dashoffset', '100');
                g.appendChild(arrowLine);

                // Animate arrow drawing
                animateArrow(arrowLine);
            }

            svg.appendChild(g);
        }

        // Animation helper functions
        function animateRipple(element, delay) {
            let start = null;
            function step(timestamp) {
                if (!start) start = timestamp + delay;
                const elapsed = timestamp - start;
                const progress = (elapsed % 2000) / 2000;

                const radius = 50 + progress * 30;
                const opacity = 0.6 * (1 - progress);

                element.setAttribute('r', radius);
                element.setAttribute('opacity', opacity);

                requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        function animateRotation(element) {
            let angle = 0;
            function step() {
                angle = (angle + 1) % 360;
                const cx = parseFloat(element.getAttribute('cx'));
                const cy = parseFloat(element.getAttribute('cy'));
                element.setAttribute('transform', `rotate(${angle} ${cx} ${cy})`);
                requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        function animateParticle(particle, centerX, centerY, angle, delay) {
            let start = null;
            function step(timestamp) {
                if (!start) start = timestamp + delay;
                const elapsed = timestamp - start;
                const progress = (elapsed % 2000) / 2000;

                const distance = 15 + progress * 25;
                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;
                const opacity = 0.8 * (1 - progress);

                particle.setAttribute('cx', x);
                particle.setAttribute('cy', y);
                particle.setAttribute('opacity', opacity);

                requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        function animateDashes(element) {
            let offset = 0;
            function step() {
                offset = (offset + 0.5) % 10;
                element.setAttribute('stroke-dashoffset', -offset);
                requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        function animateArrow(element) {
            let start = null;
            function step(timestamp) {
                if (!start) start = timestamp;
                const elapsed = timestamp - start;
                const progress = Math.min(elapsed / 1000, 1);

                const offset = 100 * (1 - progress);
                element.setAttribute('stroke-dashoffset', offset);

                if (progress < 1) {
                    requestAnimationFrame(step);
                }
            }
            requestAnimationFrame(step);
        }

        // Draw transition with ADVANCED animations and flowing particles
        function drawTransition(svg, trans) {
            const from = statePositions[trans.from];
            const to = statePositions[trans.to];
            if (!from || !to) return;

            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const angle = Math.atan2(dy, dx);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (trans.from === trans.to) {
                // Self-loop with animated dashes
                const loopX = from.x + 70;
                const loopY = from.y - 70;
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const pathD = `M ${from.x} ${from.y - 45} Q ${loopX} ${loopY} ${from.x + 45} ${from.y}`;
                path.setAttribute('d', pathD);
                path.setAttribute('stroke', 'rgba(167, 139, 250, 0.6)');
                path.setAttribute('stroke-width', '3');
                path.setAttribute('fill', 'none');
                path.setAttribute('marker-end', 'url(#arrowhead)');
                path.setAttribute('stroke-dasharray', '8 4');
                path.setAttribute('filter', 'url(#glow)');
                svg.appendChild(path);

                // Animate dashes moving along path
                animatePathDashes(path);

                // Add 2 flowing particles on self-loop
                for (let i = 0; i < 2; i++) {
                    const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    particle.setAttribute('r', 4);
                    particle.setAttribute('fill', '#a78bfa');
                    particle.setAttribute('filter', 'url(#glow)');
                    svg.appendChild(particle);
                    animateParticleAlongPath(particle, pathD, i * 1000, true);
                }

                // Label with glow
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', loopX);
                label.setAttribute('y', loopY - 5);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '12');
                label.setAttribute('fill', '#a78bfa');
                label.setAttribute('font-weight', 'bold');
                label.setAttribute('font-family', 'JetBrains Mono, monospace');
                label.setAttribute('filter', 'url(#glow)');
                label.textContent = trans.label;
                svg.appendChild(label);
            } else {
                // Regular transition with glow and particles
                const startX = from.x + 45 * Math.cos(angle);
                const startY = from.y + 45 * Math.sin(angle);
                const endX = to.x - 45 * Math.cos(angle);
                const endY = to.y - 45 * Math.sin(angle);

                // Glow background line
                const glowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                glowLine.setAttribute('x1', startX);
                glowLine.setAttribute('y1', startY);
                glowLine.setAttribute('x2', endX);
                glowLine.setAttribute('y2', endY);
                glowLine.setAttribute('stroke', 'rgba(167, 139, 250, 0.2)');
                glowLine.setAttribute('stroke-width', '6');
                glowLine.setAttribute('filter', 'url(#glow)');
                svg.appendChild(glowLine);

                // Main line with dashes
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', startX);
                line.setAttribute('y1', startY);
                line.setAttribute('x2', endX);
                line.setAttribute('y2', endY);
                line.setAttribute('stroke', 'rgba(167, 139, 250, 0.8)');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('stroke-dasharray', '8 4');
                line.setAttribute('marker-end', 'url(#arrowhead)');
                svg.appendChild(line);

                // Animate dashes
                animateLineDashes(line);

                // Add flowing particles along transition
                for (let i = 0; i < 3; i++) {
                    const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    particle.setAttribute('r', 4);
                    particle.setAttribute('fill', '#a78bfa');
                    particle.setAttribute('filter', 'url(#glow)');
                    svg.appendChild(particle);
                    animateLineParticle(particle, startX, startY, endX, endY, i * 700);
                }

                // Label with background
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                const offsetX = -20 * Math.sin(angle);
                const offsetY = 20 * Math.cos(angle);

                const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const labelText = trans.label;
                const labelWidth = labelText.length * 8 + 10;
                labelBg.setAttribute('x', midX + offsetX - labelWidth/2);
                labelBg.setAttribute('y', midY + offsetY - 12);
                labelBg.setAttribute('width', labelWidth);
                labelBg.setAttribute('height', '20');
                labelBg.setAttribute('fill', 'rgba(0,0,0,0.8)');
                labelBg.setAttribute('rx', '4');
                labelBg.setAttribute('stroke', 'rgba(167, 139, 250, 0.5)');
                labelBg.setAttribute('stroke-width', '1');
                svg.appendChild(labelBg);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', midX + offsetX);
                label.setAttribute('y', midY + offsetY + 3);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '12');
                label.setAttribute('fill', '#a78bfa');
                label.setAttribute('font-weight', 'bold');
                label.setAttribute('font-family', 'JetBrains Mono, monospace');
                label.textContent = trans.label;
                svg.appendChild(label);
            }
        }

        // Animate dashes on path (self-loops)
        function animatePathDashes(path) {
            let offset = 0;
            function step() {
                offset = (offset + 0.3) % 12;
                path.setAttribute('stroke-dashoffset', -offset);
                requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        // Animate dashes on straight lines
        function animateLineDashes(line) {
            let offset = 0;
            function step() {
                offset = (offset + 0.3) % 12;
                line.setAttribute('stroke-dashoffset', -offset);
                requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        // Animate particle along curved path
        function animateParticleAlongPath(particle, pathD, delay, isLoop) {
            let start = null;
            function step(timestamp) {
                if (!start) start = timestamp + delay;
                const elapsed = timestamp - start;
                const progress = ((elapsed % 2000) / 2000);

                // Parse path and calculate position
                const t = progress;
                // For quadratic bezier: B(t) = (1-t)¬≤P0 + 2(1-t)tP1 + t¬≤P2
                // This is simplified - in production you'd use proper SVG path parsing

                // Simple animation along the path
                const pathLength = particle.ownerSVGElement ?
                    particle.ownerSVGElement.querySelector('path')?.getTotalLength() || 100 : 100;
                const point = progress * pathLength;

                particle.setAttribute('opacity', 0.8);

                requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        // Animate particle along straight line
        function animateLineParticle(particle, x1, y1, x2, y2, delay) {
            let start = null;
            function step(timestamp) {
                if (!start) start = timestamp + delay;
                const elapsed = timestamp - start;
                const progress = ((elapsed % 2000) / 2000);

                const x = x1 + (x2 - x1) * progress;
                const y = y1 + (y2 - y1) * progress;

                particle.setAttribute('cx', x);
                particle.setAttribute('cy', y);
                particle.setAttribute('opacity', 0.8 * Math.sin(progress * Math.PI));

                requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        // Load examples
        async function loadExamples() {
            try {
                const response = await fetch('/api/examples');
                const examples = await response.json();
                const container = document.getElementById('examples-container');

                container.innerHTML = '';

                examples.valid_sequences.forEach(ex => {
                    container.innerHTML += `
                        <div class="example-card" onclick="loadExample('${ex.packets.join(',')}')">
                            <strong>‚úÖ ${ex.name}</strong>
                            <small>${ex.description}</small>
                            <div class="example-sequence">${ex.packets.join(' ‚Üí ')}</div>
                        </div>
                    `;
                });

                examples.invalid_sequences.forEach(ex => {
                    container.innerHTML += `
                        <div class="example-card" onclick="loadExample('${ex.packets.join(',')}')">
                            <strong>‚ùå ${ex.name}</strong>
                            <small>${ex.description}</small>
                            <div class="example-sequence">${ex.packets.join(' ‚Üí ')}</div>
                        </div>
                    `;
                });
            } catch (error) {
                console.error('Error loading examples:', error);
            }
        }

        // Load example
        function loadExample(packets) {
            document.getElementById('packet-input').value = packets;
        }

        // Verify sequence
        async function verifySequence() {
            const input = document.getElementById('packet-input').value;
            const packets = input.split(',').map(p => p.trim()).filter(p => p);

            if (packets.length === 0) {
                alert('Please enter a packet sequence');
                return;
            }

            try {
                await resetFSM();

                const response = await fetch('/api/verify', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ packets })
                });

                const result = await response.json();
                displayResults(result);
                animatePacketFlow(result.steps);

            } catch (error) {
                console.error('Error:', error);
            }
        }

        // Display results
        function displayResults(result) {
            const container = document.getElementById('verification-results');
            container.innerHTML = '';

            const summary = document.createElement('div');
            summary.className = `result-summary ${result.valid ? 'valid' : 'invalid'}`;
            summary.innerHTML = `
                <h3>${result.valid ? '‚úÖ Valid Protocol' : '‚ùå Invalid Protocol'}</h3>
                <p><strong>Final State:</strong> <span class="state-badge to">${result.final_state}</span></p>
                <p style="margin-top: 10px;">${result.message}</p>
            `;
            container.appendChild(summary);

            if (result.steps && result.steps.length > 0) {
                const title = document.createElement('div');
                title.className = 'section-title';
                title.textContent = 'üìã Execution Steps';
                container.appendChild(title);

                result.steps.forEach((step, index) => {
                    const stepCard = document.createElement('div');
                    stepCard.className = 'step-card';
                    stepCard.style.animationDelay = `${index * 0.1}s`;
                    stepCard.innerHTML = `
                        <span class="step-number">${index + 1}</span>
                        <span class="state-badge from">${step.old_state}</span>
                        <span style="margin: 0 8px; color: rgba(255,255,255,0.5);">‚Üí</span>
                        <span class="packet-badge">${step.packet}</span>
                        <span style="margin: 0 8px; color: rgba(255,255,255,0.5);">‚Üí</span>
                        <span class="state-badge to">${step.new_state}</span>
                    `;
                    container.appendChild(stepCard);

                    setTimeout(() => {
                        currentState = step.new_state;
                        drawFSM();
                    }, index * 600);
                });
            }
        }

        // Reset FSM
        async function resetFSM() {
            try {
                const response = await fetch('/api/reset', { method: 'POST' });
                const result = await response.json();
                currentState = result.current_state;
                drawFSM();
                clearPacketFlow();
            } catch (error) {
                console.error('Error:', error);
            }
        }

        // Step-by-step mode
        async function stepByStep() {
            const input = document.getElementById('packet-input').value;
            const packets = input.split(',').map(p => p.trim()).filter(p => p);

            if (packets.length === 0) {
                alert('Please enter a packet sequence');
                return;
            }

            await resetFSM();
            const container = document.getElementById('verification-results');
            container.innerHTML = '<div class="section-title">‚è≠Ô∏è Step-by-Step Execution</div>';

            for (let i = 0; i < packets.length; i++) {
                await new Promise(resolve => setTimeout(resolve, 1800));
                await executeStep(packets[i], i);
            }
        }

        // Execute step
        async function executeStep(packet, index) {
            try {
                const response = await fetch('/api/step', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ input: packet })
                });

                const result = await response.json();
                currentState = result.new_state;
                drawFSM();

                const container = document.getElementById('verification-results');
                const stepCard = document.createElement('div');
                stepCard.className = 'step-card';
                stepCard.innerHTML = `
                    <span class="step-number">${index + 1}</span>
                    <span class="state-badge from">${result.old_state}</span>
                    <span style="margin: 0 8px; color: rgba(255,255,255,0.5);">‚Üí</span>
                    <span class="packet-badge">${packet}</span>
                    <span style="margin: 0 8px; color: rgba(255,255,255,0.5);">‚Üí</span>
                    <span class="state-badge to">${result.new_state}</span>
                `;
                container.appendChild(stepCard);
            } catch (error) {
                console.error('Error:', error);
            }
        }

        // Packet flow setup
        function drawPacketFlowSetup() {
            const svg = document.getElementById('packet-flow-canvas');
            svg.setAttribute('viewBox', '0 0 1200 350');

            // Client
            const clientG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const clientRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            clientRect.setAttribute('x', 100);
            clientRect.setAttribute('y', 75);
            clientRect.setAttribute('width', 120);
            clientRect.setAttribute('height', 200);
            clientRect.setAttribute('fill', 'url(#clientGradient)');
            clientRect.setAttribute('rx', 15);
            clientRect.setAttribute('filter', 'url(#glow)');

            const clientGradient = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const gradient1 = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradient1.setAttribute('id', 'clientGradient');
            gradient1.setAttribute('x1', '0%');
            gradient1.setAttribute('y1', '0%');
            gradient1.setAttribute('x2', '0%');
            gradient1.setAttribute('y2', '100%');
            gradient1.innerHTML = '<stop offset="0%" style="stop-color:#10b981;stop-opacity:1" /><stop offset="100%" style="stop-color:#059669;stop-opacity:1" />';
            clientGradient.appendChild(gradient1);
            svg.appendChild(clientGradient);

            clientG.appendChild(clientRect);

            const clientText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            clientText.setAttribute('x', 160);
            clientText.setAttribute('y', 185);
            clientText.setAttribute('text-anchor', 'middle');
            clientText.setAttribute('fill', 'white');
            clientText.setAttribute('font-weight', 'bold');
            clientText.setAttribute('font-size', '18');
            clientText.textContent = 'CLIENT';
            clientG.appendChild(clientText);
            svg.appendChild(clientG);

            // Server
            const serverG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const serverRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            serverRect.setAttribute('x', 980);
            serverRect.setAttribute('y', 75);
            serverRect.setAttribute('width', 120);
            serverRect.setAttribute('height', 200);
            serverRect.setAttribute('fill', 'url(#serverGradient)');
            serverRect.setAttribute('rx', 15);
            serverRect.setAttribute('filter', 'url(#glow)');

            const gradient2 = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradient2.setAttribute('id', 'serverGradient');
            gradient2.setAttribute('x1', '0%');
            gradient2.setAttribute('y1', '0%');
            gradient2.setAttribute('x2', '0%');
            gradient2.setAttribute('y2', '100%');
            gradient2.innerHTML = '<stop offset="0%" style="stop-color:#06b6d4;stop-opacity:1" /><stop offset="100%" style="stop-color:#0891b2;stop-opacity:1" />';
            clientGradient.appendChild(gradient2);

            serverG.appendChild(serverRect);

            const serverText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            serverText.setAttribute('x', 1040);
            serverText.setAttribute('y', 185);
            serverText.setAttribute('text-anchor', 'middle');
            serverText.setAttribute('fill', 'white');
            serverText.setAttribute('font-weight', 'bold');
            serverText.setAttribute('font-size', '18');
            serverText.textContent = 'SERVER';
            serverG.appendChild(serverText);
            svg.appendChild(serverG);
        }

        // Advanced Animate packet flow with curves and trails
        function animatePacketFlow(steps) {
            const svg = document.getElementById('packet-flow-canvas');
            const packets = svg.querySelectorAll('.packet, .packet-trail, .packet-path, .packet-label-bg');
            packets.forEach(p => p.remove());

            steps.forEach((step, index) => {
                setTimeout(() => {
                    const isClientToServer = ['SYN', 'ACK'].includes(step.packet);
                    const startX = isClientToServer ? 220 : 980;
                    const endX = isClientToServer ? 980 : 220;
                    const baseY = 120 + (index * 45);

                    // Control point for bezier curve (creates arc)
                    const controlY = baseY - 40;
                    const midX = (startX + endX) / 2;

                    // Draw the path line
                    const pathLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathLine.setAttribute('class', 'packet-path');
                    pathLine.setAttribute('d', `M ${startX} ${baseY} Q ${midX} ${controlY} ${endX} ${baseY}`);
                    pathLine.setAttribute('stroke', step.valid ? 'rgba(99, 102, 241, 0.3)' : 'rgba(239, 68, 68, 0.3)');
                    pathLine.setAttribute('stroke-width', '2');
                    pathLine.setAttribute('stroke-dasharray', '5,5');
                    pathLine.setAttribute('fill', 'none');
                    svg.appendChild(pathLine);

                    // Create packet group
                    const packetGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    packetGroup.setAttribute('class', 'packet');

                    // Outer glow circle
                    const glowCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    glowCircle.setAttribute('r', 25);
                    glowCircle.setAttribute('fill', 'none');
                    glowCircle.setAttribute('stroke', step.valid ? '#6366f1' : '#ef4444');
                    glowCircle.setAttribute('stroke-width', '2');
                    glowCircle.setAttribute('opacity', '0.4');
                    packetGroup.appendChild(glowCircle);

                    // Main packet circle
                    const packet = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    packet.setAttribute('r', 20);
                    packet.setAttribute('fill', `url(#packet-gradient-${index})`);
                    packet.setAttribute('filter', 'url(#glow)');
                    packetGroup.appendChild(packet);

                    // Create gradient for packet
                    const defs = svg.querySelector('defs') || document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                    gradient.setAttribute('id', `packet-gradient-${index}`);
                    const color1 = step.valid ? '#6366f1' : '#ef4444';
                    const color2 = step.valid ? '#8b5cf6' : '#dc2626';
                    gradient.innerHTML = `
                        <stop offset="0%" style="stop-color:${color1};stop-opacity:1" />
                        <stop offset="100%" style="stop-color:${color2};stop-opacity:1" />
                    `;
                    defs.appendChild(gradient);
                    if (!svg.querySelector('defs')) svg.appendChild(defs);

                    // Packet label background
                    const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    labelBg.setAttribute('class', 'packet-label-bg');
                    labelBg.setAttribute('x', -30);
                    labelBg.setAttribute('y', 25);
                    labelBg.setAttribute('width', 60);
                    labelBg.setAttribute('height', 20);
                    labelBg.setAttribute('rx', 10);
                    labelBg.setAttribute('fill', 'rgba(0,0,0,0.8)');
                    packetGroup.appendChild(labelBg);

                    // Full packet label
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('y', 39);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('fill', 'white');
                    label.setAttribute('font-size', '10');
                    label.setAttribute('font-weight', 'bold');
                    label.setAttribute('font-family', 'JetBrains Mono, monospace');
                    label.textContent = step.packet;
                    packetGroup.appendChild(label);

                    // Direction arrow
                    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    arrow.setAttribute('y', 5);
                    arrow.setAttribute('text-anchor', 'middle');
                    arrow.setAttribute('font-size', '16');
                    arrow.textContent = isClientToServer ? '‚Üí' : '‚Üê';
                    packetGroup.appendChild(arrow);

                    svg.appendChild(packetGroup);

                    // Create trail elements
                    const trailCount = 5;
                    const trails = [];
                    for (let i = 0; i < trailCount; i++) {
                        const trail = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        trail.setAttribute('class', 'packet-trail');
                        trail.setAttribute('r', 15 - i * 2);
                        trail.setAttribute('fill', step.valid ? '#6366f1' : '#ef4444');
                        trail.setAttribute('opacity', (trailCount - i) * 0.1);
                        svg.appendChild(trail);
                        trails.push(trail);
                    }

                    // Animation parameters
                    const duration = 1500;
                    const startTime = performance.now();

                    function animate(currentTime) {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        // Easing function for smooth acceleration/deceleration
                        const eased = progress < 0.5
                            ? 2 * progress * progress
                            : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                        // Calculate position along bezier curve
                        const t = eased;
                        const currentX = Math.pow(1-t, 2) * startX +
                                       2 * (1-t) * t * midX +
                                       Math.pow(t, 2) * endX;
                        const currentY = Math.pow(1-t, 2) * baseY +
                                       2 * (1-t) * t * controlY +
                                       Math.pow(t, 2) * baseY;

                        // Update packet position
                        packetGroup.setAttribute('transform', `translate(${currentX}, ${currentY})`);

                        // Update trails with delay
                        trails.forEach((trail, i) => {
                            const trailProgress = Math.max(0, progress - (i * 0.05));
                            const trailT = trailProgress < 0.5
                                ? 2 * trailProgress * trailProgress
                                : 1 - Math.pow(-2 * trailProgress + 2, 2) / 2;

                            const trailX = Math.pow(1-trailT, 2) * startX +
                                         2 * (1-trailT) * trailT * midX +
                                         Math.pow(trailT, 2) * endX;
                            const trailY = Math.pow(1-trailT, 2) * baseY +
                                         2 * (1-trailT) * trailT * controlY +
                                         Math.pow(trailT, 2) * baseY;

                            trail.setAttribute('cx', trailX);
                            trail.setAttribute('cy', trailY);
                        });

                        // Pulse effect on glow
                        const pulseScale = 1 + Math.sin(progress * Math.PI * 4) * 0.2;
                        glowCircle.setAttribute('r', 25 * pulseScale);

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // Arrival pulse effect
                            let pulseTime = 0;
                            function pulse() {
                                pulseTime += 0.05;
                                if (pulseTime < 1) {
                                    const scale = 1 + Math.sin(pulseTime * Math.PI * 2) * 0.3;
                                    packetGroup.setAttribute('transform',
                                        `translate(${currentX}, ${currentY}) scale(${scale})`);
                                    requestAnimationFrame(pulse);
                                } else {
                                    packetGroup.setAttribute('transform',
                                        `translate(${currentX}, ${currentY})`);
                                }
                            }
                            pulse();
                        }
                    }

                    requestAnimationFrame(animate);
                }, index * 1800);
            });
        }

        // Clear packet flow
        function clearPacketFlow() {
            const svg = document.getElementById('packet-flow-canvas');
            const packets = svg.querySelectorAll('.packet, .packet-trail, .packet-path, .packet-label-bg');
            packets.forEach(p => p.remove());
        }
    </script>
</body>
</html>
